# Chapter02-ブール算術

## インデックス
* [2進数加算](#binary-addition)
* [符号付き2進数](#signed-binary)
* [加算器（Adder）](#adder)
* [実装リファレンス](#reference)

<a id="binary-addition"></a>

## 2進数加算
* 2進数加算を行うには、最初に一番右の桁（**最下位ビット（Least Significant Bit）**）の和を計算し、その計算結果のキャリービット（**桁上がりビット**）と次の桁の和を足し合わせる. この手続きを **最上位ビット（Most Significant Bit）** まで続ける.
* 最後のビットの和において、そのキャリービットの値が1であれば「オーバーフロー」であることを報告する.
* nビットからなる数を2進数加算するハードウェアは、3ビット加算器から構築することができる.
* 3ビット加算器は、2つのビットとキャリービットを合わせた3ビットの和を計算する論理ゲートである.
<br />

<a id="signed-binary"></a>

## 符号付き2進数
* n桁の2進数は、2のn乗通りのビット配列を生成することができる.
* 2進数で符号付き（-/+）数字を表現するためには、この2のn乗通りの領域を均等に二つに分けることが自然な方法である.
* 今日ほとんどのコンピュータで用いられる方式は、**2の補数（2's complement）** と呼ばれる方式である.
* 2の補数の性質
	* 2のn乗個の符号付き数を表すことができ、最大値は$2^n - 1$、最小値は$-2^{n-1}$となる.
	* 正の数の最上位ビットは0である.
	* 負の数の最上位ビットは1である.
	* xという数から-xを得るには、xのビットを反転させて、1を加える. 例えば、-5を得るには、5の「00...0101」をビット反転した「11...1010」に1を加えて、「11...1011」とする.
* 2の補数の優れている点は、2の補数で表した符号付き数の和は、正の数の和と同じ手順で計算できることである. 例えば、$(-2) + (-3)$は、2の補数を用いると、4ビット表現では$(1110)two + (1101)two$を計算すればよい. ビット単位の加算を行うと、1011という結果になる（オーバフロービットは取り除いている）. これは、-5の2の補数に一致する.
* 引き算は、$x - y = x + (-y)$と変換することで、引き算は足し算として扱うことができる.<br>
-> 2の補数を用いることで、単純なビット単位の加算が行えるハードウェアがあれば、特別なハードウェアを用いることなく正と負のどちらの計算も行える.
<br />

<a id="adder"></a>

## 加算器（Adder）
* 本書で触れる加算器
	* 半加算器（half adder）
		* 2つのビットの和を求める.
	* 全加算器（full adder）
		* 3つのビットの和を求める.
	* 加算器（adder）
		* 2つのnビットの和を求める.
	* インクリメンタ（incrementer）
		* 与えられた数字に1を加算する.
<br />

<a id="reference"></a>

## 実装リファレンス
* [セキュリティ・キャンプ キャンパー育成枠の活動録](https://genkai-io.hatenablog.jp/entry/2018/11/14/111204)
* [コンピュータシステムの理論と実装の1〜5章のハードウェアを実装しました（ネタバレ注意）](https://nihemak.hatenablog.com/entry/2019/04/28/150541#Not)
