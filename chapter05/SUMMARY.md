# Chapter05-コンピュータアーキテクチャ

## インデックス
* [概要](#overview)
* [プログラム内蔵方式](#stored-program)
* [ノイマン型アーキテクチャ](#neumann-architecture)
* [メモリ](#memory)
* [CPU](#cpu)
* [レジスタ](#register)
* [入出力](#in-out)
* [Hackハードウェアのプラットフォーム仕様](#hack-platform)
* [実装リファレンス](#reference)

<a id="overview"></a>

## 概要
* 本書で作ろうとしているコンピュータ（Hack）は、2つの重要な性質を持つ.
	* Hackは、シンプルなマシンであり、これまでに構築した回路と本書が提供するハードウェアシミュレータを用いれば、ものの数時間で作ることができる.
	* Hackは、十分にパワフルなマシンであり、デジタルコンピュータの主要な動作原理とハードウェア要素を兼ね備えている.
* Hackを作ることで、「現代のコンピュータがどのように動作しているのか」ということについて、ハードウェアとソフトウェアの低レイヤのレベルで理解することができる.
* Hackは、ノイマン型コンピュータである.

<br />

<a id="stored-program"></a>

## [プログラム内蔵方式](https://medium-company.com/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E5%86%85%E8%94%B5%E6%96%B9%E5%BC%8F/)
* コンピュータでさまざまなアプリケーション（インタラクティヴなゲーム、ワードプロセッサ、科学計算など）を行うことができるのは、**プログラム内蔵（stored program）方式** と呼ばれる素晴らしいアイデアによってもたらされた恩恵である.
* プログラム内蔵方式とは、プログラムを実行する時に、ハードディスクなどに保存してあるプログラムを主記憶装置（メインメモリ）に格納し、CPUがこれを読み取りながら実行を行う方式のことである. ストアドプログラム方式とも呼ばれる.
<br />

<a id="neumann-architecture"></a>

## [ノイマン型アーキテクチャ](https://medium-company.com/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E5%86%85%E8%94%B5%E6%96%B9%E5%BC%8F/)
* プログラム内蔵方式を採用しているコンピュータのことを **ノイマン型コンピュータ** と呼び、現在普及しているコンピュータのほとんどがノイマン型コンピュータである.
* コンピュータモデルでは、**万能チューリングマシン** と **ノイマン型コンピュータ** が重要である.
* [チューリングマシン（抽象化された人工的なコンピュータであり、見かけによらず単純なコンピュータ）](https://e-words.jp/w/%E3%83%81%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%9E%E3%82%B7%E3%83%B3.html)は、主にコンピュータシステムの理論的な側面を分析するために用いられる. チューリングマシンは、1936年にアラン・チューリングが考案した、計算を行う自動機械の数学的なモデルであり、形式的な記号操作の組み合わせと繰り返しで構成されるすべての計算を実行することができる、最も単純化されたコンピュータのモデルとして知られる.
* ノイマン型コンピュータは、実用的なアーキテクチャである. ノイマン型アーキテクチャは、CPUを中心として、メモリデバイスを操作し、入力デバイスからデータを受け取り、出力デバイスへデータを送信する. このアーキテクチャの心臓部は、「プログラム内蔵」という方式にある. プログラム内蔵が意味することは、コンピュータのメモリに格納されるデータは、コンピュータが計算したデータだけではなく、コンピュータに何を行うべきかを指示する「命令」も含まれるということである.
<br />

<a id="memory"></a>

## メモリ
* ノイマン型コンピュータのメモリには、2種類の情報が格納される. 一つはデータ項目であり、もう一つはプログラミング命令である.
* データ項目とプログラミング命令は、共にバイナリで表現され、ランダムアクセス構造のメモリに格納される点は同じである.
* ランダムアクセス構造とは、固定幅のセルが連続して配列上に並んだ構造であり、固定幅のセルは「ワード」や「ロケーション」と呼ばれ、一意のアドレスを持つ.
* データメモリ
	* 高水準言語で書かれたプログラムでは、変数、配列、オブジェクトといった「高水準（高級）」なデータ形式を操作することができる.
	* それらのデータ形式は、機械語に変換されるとバイナリデータになり、コンピュータのデータメモリに格納される.
	* 各ワードがデータメモリからアドレスによって指定されれば、そのアドレスのデータに対して、「読み込み」または「書き込み」のどちらかを行うことができる.
* 命令メモリ
	* 高水準言語で書かれたコマンドが機械語に変換されると、それらはバイナリの機械語の命令を表すようになる.
	* これらの命令は、コンピュータの命令メモリに格納される.
	* コンピュータが命令を実行するたびに、CPUは命令メモリから命令をフェッチし（読み込み）、その命令をデコード（解読）する. そして、指定された命令を実行し、次に実行すべき命令の場所を計算する.
<br />

<a id="cpu"></a>

## CPU
* CPUの役割は、現在読み込まれているプログラムの命令を実行することである.
* これらの命令がCPUに指示することは、さまざまな計算を実行させることや、メモリから値を読み書きすること、条件に応じてプログラム中の他の命令場所に移動することなどである.
* CPUは、このようなタスクをALU、レジスタ、制御ユニットを用いて実行する.
* ALU
	* ALUは、下位レベルの算術演算と論理演算を行うように設計されており、その設計がそのコンピュータを特徴づける.
	* 一般的なALUが実行できる処理は、2つの数値の加算やワードのビット操作、与えられた数が正かどうかの判定などである.
* レジスタ
	* CPUは、単純な計算を"素早く"行うように設計されている.
	* パフォーマンスを向上させるため、計算結果を遠く離れたメモリに出し入れするのではなく、近くの場所に格納するのが望ましい.
	* そのため、CPUにはハイスピードなレジスタが少数備えられている.
* 制御ユニット
	* 命令のデコードは、**制御ユニット** によって行われる.
	* 制御ユニットは、次にどの命令をフェッチし実行するかという情報も保持する.
	* これでCPUの命令は、ループ処理のように記述することができる. このループ処理は、メモリから命令をフェッチする->その命令をデコードする->その命令を実行する->次の命令をフェッチする->メモリから命令を...という流れである.
	* 命令の実行には、ALUに何らかの計算をさせること、内部レジスタを操作すること、メモリからワードを読み込むこと、メモリにワードを書き込むことなどの仕事が伴う. このようなタスクを実行する過程で、CPUは次にフェッチし実行すべき命令がどこにあるかという情報も得る.
<br />

<a id="register"></a>

## レジスタ
* 「メモリアドレスがjにあるデータを取得せよ」とCPUが命令すると、次の手続きが発生する.
	* CPUからRAMのアドレス入力へjという値が送られる.
	* RAMの「ダイレクトアクセス論理回路」は対象のメモリレジスタ（アドレスがj）を選ぶ.
	* RAM[j]のデータをCPUへ送る.<br>
	-> このような一連の手続きを行うため、メモリアクセスには時間を要する.<br>
	-> レジスタは一連の手続き必要としない. レジスタは、メモリと同じようにデータの取得と格納を行う. メモリ間の往復とメモリ中の探索のために必要な時間はゼロである.
* レジスタで理解すべきことは2点ある.
	* レジスタは、CPU回路の中に物理的に存在する.
		* CPU回路の中にあるため、アクセスは一瞬である.
	* 何百万と存在するメモリ中のセルと比較すると、レジスタは数える程度しか存在しない.
		* 機械語による命令でレジスタを指定するにはわずかなビットがあれば十分であり、結果として機械語の命令フォーマットをより短くすることができる.
* データレジスタ
	* データレジスタは、簡易的なメモリのような役割で使用される.
* アドレスレジスタ
	* メモリアクセスを伴う命令はすべて、メモリのどのワードにアクセスするかということをアドレスで指定しなければならない. このアドレスは、現在の命令の中に含まれているかもしれないし、一つ前の命令の実行結果に依存して決定されるかもしれない. 後者の場合、アドレスの値は専用のレジスタに格納される. このレジスタがアドレスレジスタである.
* プログラムカウンタレジスタ
	* プログラムを実行する時、命令メモリから次にフェッチすべき命令のアドレスについて、その過程をCPUは追う必要がある.
	* このアドレスは、「プログラムカウンタ」または「PC」と呼ばれる特別なレジスタに保持される.
	* 現在の命令に「goto」命令が含まれていない場合、プログラムの次の命令を指すようにPCの値はインクリメントされる.
	* 現在の命令に「goto n」命令が含まれている場合、CPUはPCにnを書き込む.
<br />

<a id="in-out"></a>

## 入出力
* コンピュータの外にある環境とインタラクティブにやりとりするために、コンピュータはI/Oデバイス（入出力装置）を用いる. これには、スクリーン、キーボード、プリンタ、スキャナ、ネットワークカード、USBデバイスなどが含まれる.
* **メモリマップドI/O** によって、すべてのデバイスはコンピュータにとって全く同じに見えるようになる.
* メモリマップドI/Oの基本的なアイデアは、I/Oデバイスのための領域をメモリ上に割り当てることである. そうすることで、I/OデバイスをCPUにとっては通常のメモリ領域のように"見せかける"ことができる.
* そのためには、各I/Oデバイスに排他的なメモリ領域を確保し、専用の"メモリマップ"を構成する必要がある.
* 入力装置の場合（キーボード、マウス）、デバイスの物理的な状況を常に"反映"するようにメモリマップは作られる.
* 出力装置の場合（スクリーン、スピーカー）、デバイスの物理的な状況を常に"駆動"するようにメモリマップは作られる.
* 外部のイベントが入力装置に影響を及ぼした場合（キーボードのキーを押す、マウスを動かす）、対応するメモリマップに値が書き込まれる.
* 出力装置を操作したい場合（スクリーンに描画する、スピーカーから音を鳴らす）、対応するメモリマップに値を書き込む.
* 新しいI/Oデバイスをコンピュータに接続する場合、やるべきことは新しいメモリマップを割り当て、そのベースアドレスを覚えておくことだけである（この一度限りの設定は、通常オペレーションシステムによって行われる）.
<br />

<a id="hack-platform"></a>

## Hackハードウェアのプラットフォーム仕様
* 概観
	* Hackプラットフォームは、16ビットのノイマン型コンピュータである.
	* CPUが1つ、メモリモジュールが2つ（命令メモリとデータメモリ）、メモリマップドI/Oが2つ（スクリーンとキーボード）から構成される.
	* Hackコンピュータは、命令メモリに存在するプログラムを実行する. 
	* 命令メモリは、読み込み専用のデバイスであるから、何らかの特別な方法を使用してプログラムをロードする必要がある. たとえば、必要とするプログラムがすでに書き込まれたROM回路を用いることで、命令メモリの仕組みを実現することができる. 新しいプログラムをロードするためには、新しいROM回路に差し替えればよい.
	* HackのCPUは、ALUと3つのレジスタから構成される. 3つのレジスタは、「データレジスタ（D）」「アドレスレジスタ（A）」「プログラムカウンタ（PC）」と呼ばれる. Dレジスタは、データを保持するためだけに用いられるが、Aレジスタの内容は、使用される命令に応じて3つの異なる意味として解釈される. それは、データ値、RAMアドレス、ROMアドレスである.
	* Hack機械語は、2種類の16ビット命令をベースとしている. アドレス命令は「0vvvvvvvvvvvvvvv」というフォーマットに従う（vは0または1を表す）. この命令を実行すると、コンピュータは15ビットのvvv...vという値をAレジスタに設定する. 計算命令は、「111accccccdddjjj」というフォーマットに従う. aビットとcビットは、ALUに行うべき関数を支持し、dビットは、ALUの出力を格納する場所を指定する. jビットは、（オプションとして）移動条件を指定する.
	* コンピュータアーキテクチャにおいて、プログラムカウンタ（PC）回路の出力は、ROM回路のアドレス入力に接続されるように配線されている. そのため、ROM回路からは常にROM[PC]、つまり、命令メモリ中でPCが"指さす"場所のデータ値が出力される. この値は、「現在命令」と呼ばれる.
	* 各クロックサイクル中におけるコンピュータ全体の操作は、次の2つの操作からなる.
		* 実行
			* 現在命令を構成するビットは、コンピュータのさまざまな回路へ送られる.
			* もしそれがアドレス命令（一番左のビットが0）であれば、命令に埋め込まれた15ビットの定数値がAレジスタに設定される.
			* もしそれが計算命令（一番左のビットが1）であれば、a、c、d、jビットは制御ビットとして扱われ、ALUとレジスタに命令を実行させる.
		* フェッチ
			* 次にどの命令をフェッチする（読み込む）かということは、「現在命令のジャンプビット（jビット）」と「ALUの出力」によって決まる. この2つの要素からジャンプを実行すべきかどうかが決定される.
			* もしジャンプを行う場合は、PCにAレジスタの値を設定する. それ以外は、PCの値は1だけインクリメントされる.
			* 次のクロック周期において、プログラムカウンタの指す命令がROMの出力から送信される.
	* Hackプラットフォームにおいて、メモリアクセスを伴う操作は2つの命令を必要とする. 一つは、アドレス命令で、Aレジスタに特定のアドレスを設定する. もう一つは、それに続く計算命令で、このアドレスに対して何らかの操作（RAMへの読み書き命令、ROMへの移動命令）を行う.
	* CPUは、2章で作成したALUをベースとする. レジスタとプログラムカウンタは、3章で作成した16ビットレジスタと16ビットカウンタを複製したものである.
	* ROMとRAM回路は、3章で作成したメモリユニットである.
	* スクリーンとキーボードのための回路は、ビルトイン版の回路で用意されており、これはRAM回路と同じインターフェイスを持つ.
* CPU
	* HackプラットフォームのCPUは、4章で示したHack機械語の仕様に従って16ビットの命令を実行できるように設計されている.
	* CPUは、2つの分離されたメモリモジュールである命令メモリとデータメモリに接続される.
	* 命令メモリからは命令をフェッチし、データメモリへは値の読み込みを行う.
* 命令メモリ
	* Hackの命令メモリは、直接アクセスできる読み込み専用のメモリ装置であり、ROMと呼ばれる.
	* HackのROMは、32Kのアドレスを持ち、各アドレスには16ビットレジスタが配置されている.
* データメモリ
	* Hackのデータメモリ回路は、3章で作成したようなRAMと同じインターフェイスを持つ.
	* データレジスタのn番目のレジスタの値を読み込むためには、メモリ入力のaddressにnを設定し、メモリ出力のoutを調べるようにする. これは、「組み合わせ操作」であるから、この命令はクロックとは独立して動作する.
	* n番目のレジスタにvという値を書き込むためには、入力のinにvを、addressにnを、メモリのloadビットを1に設定する. これは、「順序操作」であるから、新しい値であるvがn番目のレジスタに書き込まれるタイミングは次のクロック周期において行われる.
	* データメモリは、汎用的なデータの格納に用いられるのに加えて、メモリマップを用いてI/OデバイスとCPUとの間のインターフェイスとなる.
* メモリマップ
	* ユーザとインタラクティブなやりとりをするために、Hackプラットフォームはスクリーンとキーボードの2つの周辺機器と接続することができる. これらのデバイスは、両方共にメモリマップを通じてコンピュータと情報をやりとりする.
	* スクリーンの画像は、対応するメモリの場所を読み書きすることで、描画とそのピクセルの値を調べることができる.
	* 現在どのキーが押されているかを調べるには、キーボード用のメモリマップにおいて指定された場所のメモリの値を調べればよい.
	* メモリマップは、コンピュータの外部に存在する周辺機器用の論理回路を通して、それが対象とするI/Oデバイスに作用する.
* スクリーン
	* Hackコンピュータは、横512×縦256ピクセルの白黒のスクリーンと接続することができる.
	* コンピュータは、物理的なスクリーンとメモリマップを介して接続される. このメモリマップは、Screenと呼ばれる回路で実装されており、この回路は通常のメモリのように動作する. つまり、メモリのように読み書きが行える.
* キーボード
	* Hackコンピュータは、パソコンで使用する標準的なキーボードと接続することができる.
	* Keyboardと呼ばれる回路を通して、コンピュータは物理キーボードと接続する.
	* 物理キーボードが押されるたびに、その16ビットのASCIIコードがKeyboard回路の出力として現れる. 何もキーが押されていない場合は、この回路の出力は0である.
* メモリ全体
	* Hackプラットフォームのアドレス空間全体（つまり、その全体のデータメモリ）は、Memoryと呼ばれる回路によって提供される.
	* Memory回路には、RAM（通常のデータストレージ）に加えて、スクリーンとキーボードのメモリマップが含まれる. これらのモジュールは、3つのセクションに分けられた単一のアドレス空間に存在する.
* コンピュータ
	* Hackのハードウェア階層において一番上に位置する回路（Computer回路）は、完全なコンピュータシステムであり、Hack機械語で書かれたプログラムを実行するように設計されている.
	* Computer回路は、コンピュータを操作するために必要なハードウェアデバイスをすべて備える. このハードウェアデバイスには、CPU、データメモリ、命令メモリ（ROM）、スクリーン、キーボードが含まれ、これらはすべて内部パーツとして実装される.
	* プログラムを実行するには、プログラムのコードをあらかじめROMに読み込む必要がある.
	* スクリーンとキーボードの制御は、メモリマップを通して行う.
<br />


<a id="reference"></a>

## 実装リファレンス
* [コンピュータシステムの理論と実装の1〜5章のハードウェアを実装しました（ネタバレ注意）](https://nihemak.hatenablog.com/entry/2019/04/28/150541#Not)
* [ikenox](https://github.com/ikenox/nand2tetris)
