# Chapter04-順序回路

## インデックス
* [概要](#overview)
* [機械語](#machine-language)
* [メモリ](#memory)
* [プロセッサ](#processor)
* [レジスタ](#register)
* [アセンブリ](#assembly)
* [算術演算と論理演算](#arithmetic-and-logical-operations)
* [メモリアクセス](#memory-access)
* [分岐命令](branch-instruction)
* [Hackの仕様](#hack-method)
* [Hackメモリアドレス空間](#hack-memory-address-space)
* [実装リファレンス](#reference)

<a id="overview"></a>

## 概要
* コンピュータを **構造的** な視点から説明するには、そのハードウェアのプラットフォームを提示し、それが下位レベルの回路からどのように構築されているかを説明すればよい.
* コンピュータを **抽象的** な視点から説明するには、その **機械語** の仕様を示し、その機械語によって何ができるかを明らかにすればよい.
* 機械語の仕様は、合意に基づく形式に従い、低水準なプログラムを一連の機械語指令としてコード化できるように設計されている. この命令を用いると、算術計算や論理計算、メモリからのフェッチ（データの読み込み）やメモリへのデータ保存、レジスタ間のデータ移動、ブーリアン値の条件テスト、などをプログラマはプロセッサに実行させることができる.
* 機械語が目標とすることは、対象とするハードウェア上で直接実行できること、そのハードウェア全体を制御できることである. 満たさなければならない唯一の基本的要求は、ハードウェア上で直接実行できることである.
* 機械語においてハードウェアとソフトウェアが交わり、機械語においてプログラマの抽象的思考（これは記号命令によって表される）がシリコン上で実行される物理的操作に変換される.
* 機械語を説明するには、3つの抽象化についてだけ考えればよい. **メモリ**、**プロセッサ**、**レジスタ** である.
<br />

<a id="machine-language"></a>

## [機械語](https://e-words.jp/w/%E6%A9%9F%E6%A2%B0%E8%AA%9E.html)
* 機械語は、仕様によって決められた形式に従い、プロセッサとレジスタを用いてメモリを操作するように設計されている.
* コンピュータのマイクロプロセッサ（CPU/MPU）が直接解釈・実行できる命令コードの体系.
* 0と1を並べたビット列（バイナリコード）として表され、人間が直に読み書きしやすい形式ではない.
* 機械語は、プロセッサに直接命令を与える言語であるため、プロセッサの持つすべての機能を利用することができる.
* どのようなプログラミング言語で記述されたプログラムであっても、ソフトウェアによる変換や調整を経て、最終的には機械語のプログラムとしてプロセッサに渡され実行される.
<br />

<a id="memory"></a>

## メモリ
* コンピュータでデータや命令を保存するハードウェアデバイス.
* ある固定幅のセル（**ワード** や **ロケーション** とも呼ばれる）が連続して並んでおり、それぞれがユニークな **アドレス** を持つ.
* 個々のワード（データもしくは命令を表す）は、アドレスによって指定される.
<br />

<a id="processor"></a>

## プロセッサ
* **中央演算装置（Central Processing Unit）** や **CPU** と呼ばれ、仕様で決められた命令セットを実行する.
* 命令セットには、算術演算と論理演算、メモリアクセス演算、制御演算（ブランチ）などが含まれる. 演算のオペランド（演算の対象）は、レジスタやメモリから取り出されるバイナリデータである.
* 演算の結果もレジスタもしくはメモリに格納することができる.
<br />

<a id="register"></a>

## [レジスタ](https://e-words.jp/w/%E3%83%AC%E3%82%B8%E3%82%B9%E3%82%BF.html)
* マイクロプロセッサ（CPU/MPU）内部にある、演算や実行状態の保持に用いる記憶素子.
* メモリへのアクセスは時間のかかる操作であり、毎回メモリから読み出し/書き込みを行っていると処理時間が遅くなる. そのため、プロセッサ内部にレジスタを置くことで、高速にアクセスできる.
* 各レジスタは、1つの値だけを保持できるようになっている.
<br />

<a id="assembly"></a>

## アセンブリ
* 機械語（バイナリコード）のプログラムは、一連の符号化された命令である. それだけでは判読できないため、通常バイナリコードとニーモニックの両方を用いて記述される.
* **ニーモニック** は、記号や英単語で記述され、その名前によって何を行う命令かを把握することができる. たとえば、「1010という命令コードはニーモニックで表すとADDとする」といったことを設計者は決めることができる.
* この記号（ニーモニック）による抽象化をさらに進めると、記号による表記は読むためだけでなく、プログラムを書くためにも用いることができる. つまり、バイナリコードで書く代わりに、記号によるコマンドを用いてプログラムを書くことができる.
* この記号による表記は、**アセンブリ言語** または、単に **アセンブリ** と呼ばれ、アセンブリから機械語であるバイナリコードへ変換するプログラムは **アセンブラ** と呼ばれる.
* コンピュータが異なれば、CPUの命令セット、レジスタの数や種類などが違うため、機械語が異なる. そのため、アセンブリの構文ルールも異なる. ただし、どのような機械語であれ、同じような一般的なコマンドをサポートしている.
<br />

<a id="arithmetic-and-logical-operations"></a>

## 算術演算と論理演算
* どのようなコンピュータであれ、加算/減算のような算術演算や、ビットシフト・ビット単位の否定のような論理演算を実行できることが求められる.
* 一般的なアセンブリのシンタックスで書かれた例は以下のようになる.
	```
	ADD R2 R1 R3	// R2 <- R1 + R3（R1、R2、R3はレジスタ）
	ADD R2 R1 foo	// R2 <- R1 + foo（fooはユーザが定義したラベルであり、そのラベルが指す位置にあるメモリの値）

	AND R1 R1 R2	// R1 <- R1とR2のビット単位AND
	```
<br />

<a id="memory-access"></a>

## メモリアクセス
* メモリアクセスを行う場合は2つの場合が考えられる.
	1. 算術演算や論理演算を行う.
	2. メモリに対して明示的に読み込み（load）や格納（store）を行う.
* メモリアクセスを行うコマンドは、**アドレッシングモード** を用いており、アドレッシングモードにはいくつかの種類が存在する.
* 直接アドレッシング
	* メモリのアドレスを指定する最も一般的な方法.
	* 直接アドレスを指定する、もしくはシンボルを用いて特定のアドレスを参照する.
	* 例
		```
		LOAD R1 67	// R1 <- Memory[67]

		// barの参照する値が67である場合
		LOAD R1 bar	// R1 <- bar <- Memory[67]
		```
* イミディエイトアドレッシング
	* 定数を読み込むために用いられる.
	* 命令中に現れる数値領域をアドレスとして扱う代わりに、その値をそのままレジスタに読み込む.
	* 例
		```
		LOADI R1 67	// R1 <- 67
		```
* 間接アドレッシング
	* ポインタを扱うのに用いられる.
	* 例
		```
		// x = foo[j] もしくは x = *(foo+j) の変換
		ADD R1 foo j	// R1 <- foo + j
		LOAD R2 R1		// R2 <- Memory[R1]
		STR R2 x		// x <- R2
		```
<br />

<a id="branch-instruction"></a>

## 分岐命令
* 分岐命令には、以下のようなものがある.
	* 反復
		* ループ処理の開始位置に戻る.
	* 条件分岐
		* もし条件がfasleであれば、「if-then節」の後ろにある位置に移動する.
	* サブルーチン呼び出し
		* あるコードセグメントの最初のコマンドに移動する.
		* [サブルーチン](https://e-words.jp/w/%E3%82%B5%E3%83%96%E3%83%AB%E3%83%BC%E3%83%81%E3%83%B3.html)とは、コンピュータプログラムの中で特定の機能や処理をひとまとまりの集合として定義し、他の箇所から呼び出して実行できるようにしたもの.
* 高水準/低水準における分岐ロジック
	* 高水準
		```
		// whileループ
		while (R1 >= 0) {
			code segment 1
		}
		code segment 2
		```
	* 低水準
		```
		// 一般的な変換
		beginWhile:
			JNG R1 endWhile		// もしR1<0であればendWhileへ移動
			// 「code segment 1」の変換コードはここにくる
			JMP beginWhile		// beginWhileへ移動
		endWhile:
			// 「code segment 2」の変換コードはここにくる
		```
		* 「JMP beginWhile」のような **無条件分岐** を行うコマンドは、目的とする位置のアドレスだけを指定する.
		* 「JNG R1 endWhile」のような **条件分岐** では、ブール条件も何らかの方法で指定しなければならない.
<br />

<a id="hack-method"></a>

## Hackの仕様
* Hackコンピュータは、ノイマン型のプラットフォームである. ノイマン型コンピュータとは、ストアドプログラム方式（メモリ上にプログラムをロードし、CPUそれを読み取りながら実行する）のコンピュータである.
* 16ビットのマシンであり、CPU、メモリモジュール、メモリマップドI/Oデバイスを備える. 
* メモリモジュールには、命令用とデータ用のメモリが離れた場所に存在する.
* メモリマップドI/Oデバイスは、スクリーン用とキーボード用の2つがある.
<br />

<a id="hack-memory-address-space"></a>

## Hackメモリアドレス空間
* Hackプログラマは、2つの異なるアドレス空間があることを知る必要がある. 命令メモリとデータメモリである. 両方のメモリは、共に16ビット幅であり、15ビットのアドレス空間を持つ.
* CPUは、命令メモリに存在するプログラムだけを実行することができる. 命令メモリは、読み込み専用メモリ（ROM）であり、プログラムの読み込みには外部の仕組みを利用する.
* 命令メモリの読み込みには、たとえば、必要なプログラムがすでに書き込まれたROM回路を用いることによって実現できる. これは、ゲーム機のカセットを入れ替えるのと同じ仕組みである.
<br />

<a id="reference"></a>

## 実装リファレンス
* [コンピュータシステムの理論と実装の1〜5章のハードウェアを実装しました（ネタバレ注意）](https://nihemak.hatenablog.com/entry/2019/04/28/150541#Not)
* [ikenox](https://github.com/ikenox/nand2tetris)
